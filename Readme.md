### useThrottledPromiseQueue

Функция работает по следующему алгоритму:
1) Она достает из очереди все элементы (callback функции), и отбрасывает все кроме последней
2) Она исполняет последнюю callback функцию, подписываясь на .resolve() и .catch() возвращенного промиса
3) В промежутке между резолвом промиса пользователь добавляет новые колбеки в очередь
4) Когда промис резолвится или падает - алгоритм повторяется

Это может полезно для странички поиска, где пользователь вбивает символы быстрее, чем получает ответ от сервера.
Невозможность одновременного исполнения промисов гаранитирует, что запросы не будут слишком долго ждать и не "перепутаются",
как это может случиться при использовании классического throttle со слишком длинным или коротким таймером.
```js
const {
    enqueue: enqueueUsers,
    isProcessing: isLoadingUsers, // Можно использовать для отображения лоадера
} = useThrottledPromiseQueue();

const loadUsers() {
  // Необходимо оборачивать промис, который вы хотите тротлить
  // в дополнительную функцию (перед "async () =>"), чтобы он не исполнился "на месте" 
  enqueueUsers(() => async () => {
    response = await axios.get('/users');
    users.value = response.data.users;
  });
}

// Делаем сразу кучу "запросов"
for (let i = 0; i < 12; i++;) {
  setTimeout(
    () => loadUsers(),
    10 * i,
  );
}
```
